---
title: " Vignette illustrating the use of MOFA on the CLL data"
author: "Britta Velten and Ricard Argelaguet"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Example_CLL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette show how to use MOFA including initialization, training and down-stream analysis.
For illustration we use the CLL data which is used in the MOFA publication.

```{r, warning=FALSE, message=FALSE}
library(MOFAtools)
```

# Step 1: Load data and create MOFA object
There are two options to input data to MOFA:

- Option 1: base R approach using a list of matrices
- Option 2: Bioconductor approach using the MultiAssayExperiment framework

## Option 1: base R approach
If using the base R approach, you simply need to provide a list of matrices where features are rows and samples are columns. Importantly, the samples need to be aligned. Missing values/assays should be filled with NAs.
```{r}
data("CLL_data")
MOFAobject <- createMOFAobject(CLL_data)
MOFAobject
```

## Option 2: bioconductor approach
If using the Bioconductor approach, you need to provide or create a [MultiAssayExperiment](https://bioconductor.org/packages/release/bioc/html/MultiAssayExperiment.html) object and then use it to build the MOFA object. For example, starting from a list of matrices where features are rows and samples are columns, this can be easily constructed as follows:
```{r}
library(MultiAssayExperiment)

# Load data
data("CLL_data") # import list containing matrices for mRNA, Methylation, Drug Response and Mutation data. 
lapply(CLL_data, dim) # check dimensionalities, samples are columns, features are rows

# Load sample metadata (colData): Sex and Diagnosis
data("CLL_covariates")
head(CLL_covariates)

# Create MultiAssayExperiment object 
mae_CLL <- MultiAssayExperiment(experiments = CLL_data, colData = CLL_covariates)

# Build the MOFA object
MOFAobject <- createMOFAobject(mae_CLL)
MOFAobject

```


## Overview of training data
The function 'plotTilesData' can be used to obtain an overview of the data stored in the object for training. For each sample it shows in which views data are available: Rows are different views, e.g. omic data sets, and columns are samples. Missing samples are denoted by a grey bar.
```{r}
plotTilesData(MOFAobject)
```

# Step 2: Fit the MOFA model
The next step is to fit the model. 
This part of the pipeline is implemented in Python, so first of all make sure you have the corresponding package installed (see installation instructions in the README file). In principle, we recommend to train the model directly from the command line (see running instructions, it is very simple), but we have created the following R wrapper if you do not feel comfortable with bash.

## Define options

### Define data options
The most important options the user needs to define are:

* **centerFeatures**: logical indicating whether to center the features to zero mean. This is optional, as the model can learn the feature-wise intercepts by setting ModelOptions$learnIntercept to TRUE. However, centered data is always recommended, so default is TRUE. Note that this only applies to continuous data that is modelled with a gaussian likelihood. Binary or count data are not centered.
* **scaleViews**: logical indicating whether to scale views to have unit variance. As long as the scale of the different data sets is not too high, this is not required. Default is FALSE.
* **removeIncompleteSamples**: logical indicating whether to remove samples that are not profiled in all omics. The model can cope with missing assays, so this option is not required. Default is FALSE.

```{r}
DataOptions <- getDefaultDataOptions()
DataOptions 
```

### Define model options
Next, we define model options. The most important are:  

* **numFactors**: number of factors (default is 25). By default, the model does not automatically learn the number of factors. If you want the model to do this (based on a minimum variance explained criteria), set `TrainOptions$dropFactorThreshold` to a non-zero value.
* **likelihoods**: likelihood for each view. Usually we recommend gaussian for continuous data, bernoulli for binary data and poisson for count data. By default, the model tries to guess it from the data.
* **sparsity**: do you want to use sparsity? This makes the interpretation easier so it is recommended (Default is TRUE).

```{r}
ModelOptions <- getDefaultModelOptions(MOFAobject)
ModelOptions
```

### Define training options
Next, we define training options. The most important are:  

* **maxiter**: maximum number of iterations. Ideally set it large enough and use the convergence criteria `TrainOptions$tolerance`.
* **tolerance**: convergence threshold based on change in the evidence lower bound. For an exploratory run you can use a value between 1.0 and 0.1, but for a "final" model we recommend a value of 0.01.
* **DropFactorThreshold**: threshold of fraction of variance explained to define a factor as inactive. This is the key parameter to let the model learn the number of factors. Factors explaining less than 'DropFactorThreshold' fraction of variation in all views will be removed. For example, a value of 0.02 means that factors that explain less than 2\% of variance in all views will be discarded. If the value is set to 0, the number of factors is not learned and the specified number of factors in ModelOptions will be used.

```{r}
TrainOptions <- getDefaultTrainOptions()
TrainOptions$seed <- 2017

# Automatically drop factors that explain less than 2% of variance in all omics
TrainOptions$DropFactorThreshold <- 0.02

TrainOptions
```

## Prepare MOFA
`prepareMOFA` internally performs a set of sanity checks and fills the `DataOptions`, `TrainOptions` and `ModelOptions` slots of the `MOFAobject`
```{r}
MOFAobject <- prepareMOFA(
  MOFAobject, 
  DataOptions = DataOptions,
  ModelOptions = ModelOptions,
  TrainOptions = TrainOptions
)
```

## Run MOFA
Now we are ready to train the `MOFAobject`, which is done with the function `runMOFA`. This step can take some time (around 15 min with default parameters). For illustration we provide an existing trained `MOFAobject`
```{r, eval=FALSE}
MOFAobject <- runMOFA(MOFAobject, outfile=tempfile())
```


```{r}
# Loading an existing trained model
filepath <- system.file("extdata", "CLL_model.hdf5", package = "MOFAtools")
MOFAobject <- loadModel(filepath, MOFAobject)
MOFAobject
```


# Step 3: Analyse a trained MOFA model
After training, we can explore the results from MOFA. Here we provide a semi-automated pipeline to disentangle and characterize the sources of variation (the factors) identified by MOFA.

Part 1: Disentangling the heterogeneity:

- Calculation of variance explained by each factor in each view

Part 2: Characterisation of individual factors:

- Inspection of top weighted features in the active views
- Feature set enrichemnt analysis in the active views (where set annotations are present, e.g. gene sets for mRNA views)
- Ordination of samples by factors to reveal clusters and graadients in the sample space

For details, please read the Methods section of the Manuscript.

## Part 1: Disentangling the heterogeneity, calculation of variance explained by each factor in each view
This is done by the `plotVarianceExplained` function. The resulting plot allows to get an overivew of which factors are active in which view(s). If a factor is active in more than one view, this means that is capturing shared signal (co-variation) between features of the different views. Here, for example Factor 1 is active in all data modalities, while Factor 4 is specific to mRNA.

```{r}
r2 <- calculateVarianceExplained(MOFAobject)
plotVarianceExplained(MOFAobject)
```

## Part 2: Characterisation of individual factors
### Inspection of top weighted features in the active views
To get an overview of the weights across all factors in a given view you can use the `plotWeightsHeatmap` function.
For example, here we plot all weights from all factors in the Mutation data:
```{r}
plotWeightsHeatmap(MOFAobject, view = "Mutations", factors=1:5, show_colnames=F)
```

We see strong contributions of features in the Mutations data modality for Factor 1 and 2. To investiate a single factor in detail we can  use the 'plotWeights' function, which shows us all weights of the specified view (here Mutations) on this factor (e.g. Factor 1). Features with large (absolute) weight in a given factor means that they follow the pattern of covariation associated with the factor. This reveals in our case a strong link to the IGHV status which has a large negative weight on this factor, hence recoverig an importatn clinical marker in CLL (see our [paper](http://msb.embopress.org/content/14/6/e8124) for details on the biological interpretation.) Note that the sign of the weigth can only be interpreted relative to the signs of other weights and the factor values.
```{r}
plotWeights(MOFAobject, view = "Mutations", factor = 1)
```

If you are only interested in looking at the top features you can use the 'plotTopWeights' function.
For example, here we plot the mutations with largest loadings on Factor 1, revealing again the important role of IGHV status.
```{r}
plotTopWeights(MOFAobject, "Mutations", 1)
```

Similarly, we find a link to trisomy 12 for Factor 2:
```{r}
plotTopWeights(MOFAobject, "Mutations", 2)
```

From the previous plots, we can clearly see that Factor 1 is associated to IGHV status. As the variance decomposition above told us that this factor is also relevant on all the other data modalities we can investigate its weights on other modalities, e.g. mRNA, to make connections of the IGHV-linked axes of variation to other molecular layers.
```{r}
plotTopWeights(MOFAobject, "mRNA", 1)
```

Finally, instead of looking at an the "abstract" weight, it is useful to observe the coordinated heterogeneity of the top features in the original data. This can be done using the 'plotDataHeatmap' function. Here samples (in rows) are ordered according to their value on the factor (here Factor 1). Here, this shows clear patterns of the samples' gene expression in the 20 top weighted genes.
```{r}
plotDataHeatmap(MOFAobject, view="mRNA", factor=1, features=20, show_rownames=FALSE)
```

### Feature set enrichment analysis in the active views
Sometimes looking at the loadings of single features can be challenging, and often the combination of signal from functionally related sets of features (i.e. gene ontologies) is required.

Here we implemented a function for feature set enrichment analysis method (FeatureSetEnrichmentAnalysis) derived from the [PCGSE package](https://cran.r-project.org/web/packages/PCGSE/index.html).

The input of this function is a MOFA trained model (MOFAmodel), the factors for which to perform feature set enrichment (a character vector), the feature sets (a binary matrix) and a set of options regarding how the analysis should be performed, see also documentation of `FeatureSetEnrichmentAnalysis`

We illustrate the use of this function using the [reactome](http://reactome.org) annotations.
```{r}
# Load reactome annotations, binary matrix with feature sets in rows and feautres in columns
data("reactomeGS")

# perfrom enrichment analysis
fsea.out <- FeatureSetEnrichmentAnalysis(MOFAobject, "mRNA", reactomeGS, alpha = 0.01)
```

The next step is to visualise the results of the Gene Set Enrichment Analysis. There are two default plots:

(a) General Overview: Barplot with number of enriched gene sets per view

```{r}
Barplot_FeatureSetEnrichmentAnalysis(fsea.out, alpha=0.01)
```
From this we find enriched at a FDR of 1% gene sets on Factors 3-6 and 8. To look into which gene sets these are we can choose a factor of interest and visualize the most enriched gene sets as follows:

(b) Factor-specific:
```{r}
interestingFactors <- 4:5
for (factor in interestingFactors) {
  lineplot <- LinePlot_FeatureSetEnrichmentAnalysis(fsea.out, factor, threshold=0.01, max.pathways=10)
  print(lineplot)
}
```


Here, this shows us that Factor 4 is capturing variation related to immune response (possibly due to T-cell contamination of the samples) and Factor 5 is related to differences in stress response, as discussed in our [paper](http://msb.embopress.org/content/14/6/e8124).

## Ordination of samples by factors to reveal clusters and graadients in the sample space

Samples can be visualized along factors of interest using the `FactorsScatterPlot` function.
```{r}
plotFactorScatter(MOFAobject, factors = 1:2, color_by = "IGHV", shape_by = "trisomy12")
```
Here we find again a clear separation of samples based on their IGHV status (color) along Factor 1 and by the absence or prescence of trisomy 12 along Factor 2 as indicated by the corresponding factor weights in the Mutations view.

An overview of pair-wise sctterplots for all or a subset of factors is produced by the `FactorsScatterPairs` function
```{r}
plotFactorScatters(MOFAobject, factors = 1:4, color_by = "IGHV")
```

A single factor can be visualised using the `FactorBeeswarmPlot` function. (Here for Factor 1 showing again the separation of samples by their IGHV status).
```{r}
plotFactorBeeswarm(MOFAobject, factors = 1, color_by = "IGHV")
```

## Customized analysis
For customized exploration of weights and factors, you can directly fetch the variables from the model using 'get' functions: `getWeights`, `getFactors` and `getTrainData`. 
```{r}
MOFAweights <- getWeights(MOFAobject, views="all", factors="all", as.data.frame = T)
head(MOFAweights)
```

```{r}
MOFAfactors <- getFactors(MOFAobject, factors=c(1,2), as.data.frame = F)
head(MOFAfactors)
```

```{r}
MOFAdata <- getTrainData(MOFAobject, as.data.frame = T, views = "Mutations")
head(MOFAdata)
```


# Further functionalities 

## Prediction of views
With the `predict` function, full views can be predicted based on the MOFA model with all or a subset of factors
```{r}
predictedDrugs <- predict(MOFAobject, view="Drugs", factors="all")
```

## Imputation of missing observations
With the 'imputeMissing' function all missing values are imputed based on the MOFA model. The imputed data is then stored in the ImputedData slot of the MOFAobject and can be accessed via the `getImputedData` function.
```{r}
MOFAobject <- imputeMissing(MOFAobject)
imputedDrugs <- getImputedData(MOFAobject, view="Drugs")
```

## Clustering of samples based on latent factors
Samples can be clustered according to their values on some or all latent factors using the `clusterSamples` function. Clusters can for example be visualised using the FactorsScatterPlot function
```{r}
clusters <- clusterSamples(MOFAobject, k=2, factors=1)
plotFactorScatter(MOFAobject, factors=1:2, color_by=clusters)
```


